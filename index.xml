<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LiuHuang&#39;s Blog</title>
    <link>https://Littlehalo.github.io/</link>
    <description>Recent content on LiuHuang&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 09 Apr 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://Littlehalo.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>constructor</title>
      <link>https://Littlehalo.github.io/posts/js%E4%B8%AD%E7%9A%84constructor/</link>
      <pubDate>Tue, 09 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://Littlehalo.github.io/posts/js%E4%B8%AD%E7%9A%84constructor/</guid>
      <description> __proto__和constructor属性是对象所独有的； prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。 __proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，然后返回undefined，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。 prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.proto === Foo.prototype。 constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 另外 proto 属性是浏览器对es5的实现，而不是es标准。  </description>
    </item>
    
    <item>
      <title>Object.prototype.toString.call()</title>
      <link>https://Littlehalo.github.io/posts/object.prototype.tostring.call/</link>
      <pubDate>Tue, 09 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://Littlehalo.github.io/posts/object.prototype.tostring.call/</guid>
      <description>使用Object.prototype上的原生toString()方法判断数据类型，使用方法如下： Object.prototype.toString.call(value)
//1.判断基本类型：Object.prototype.toString.call(null);//”[object Null]”Object.prototype.toString.call(undefined);//”[object Undefined]”Object.prototype.toString.call(“abc”);//”[object String]”Object.prototype.toString.call(123);//”[object Number]”Object.prototype.toString.call(true);//”[object Boolean]”//2.判断原生引用类型：//函数类型Function fn(){console.log(“test”);}Object.prototype.toString.call(fn);//”[object Function]”//日期类型var date = new Date();Object.prototype.toString.call(date);//”[object Date]”// 数组类型var arr = [1,2,3];Object.prototype.toString.call(arr);//”[object Array]”//正则表达式var reg = /[hbc]at/gi;Object.prototype.toString.call(arr);//”[object Array]”//自定义类型function Person(name, age) {this.name = name;this.age = age;}var person = new Person(&amp;quot;Rose&amp;quot;, 18);Object.prototype.toString.call(arr); //”[object Object]”//很明显这种方法不能准确判断person是Person类的实例，而只能用instanceof 操作符来进行判断，如下所示：console.log(person instanceof Person);//输出结果为true//3.判断原生JSON对象： var isNativeJSON = window.</description>
    </item>
    
    <item>
      <title>函数作用域预编译</title>
      <link>https://Littlehalo.github.io/posts/js%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Tue, 09 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://Littlehalo.github.io/posts/js%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>函数作用域预编译  创建ao对象 找形参和变量声明 将形参和变量名 当做AO对象的属性名，值为undefined 实参形参统一 在函数体里面找函数声明，赋值  全局作用域的预编译  创建GO对象 找变量声明 将变量名作为GO对象的属性名 值为undefined 找函数声明，赋值  作用域链 保存在[scope]中，用户访问不到但是存在，js引擎可以访问到
闭包的理解（内部函数在外部可以调用） 闭包的引用：js的防抖和节流
防抖function debounce(fun,delay){let timerreturn function(args){clearTimeout(timer)timer = setTimeout(function(){fun(args)},delay)}}节流function throottle(fun,wait){let timeoutreturn function(){if(!timeout){timeout = setTimeout(function(){timeout=nullfun},wait)}}}深拷贝浅拷贝 　JS分两种数据类型：
　基本数据类型（存放在栈中）**：**Number、String、Boolean、Null、 Undefined、Symbol（ES6），**这些类型可以直接操作保存在变量中的实际值。
　引用数据类型（存放在堆内存中的对象）：Object（在JS中除了基本数据类型以外的都是对象，数据是对象，函数是对象，正则表达式是对象）
​	赋值：
​	浅拷贝：
​	深拷贝：
绑定this指向  call apply bind  </description>
    </item>
    
    <item>
      <title>vue中axios的封装</title>
      <link>https://Littlehalo.github.io/posts/vue%E4%B8%ADaxios%E5%B0%81%E8%A3%85/</link>
      <pubDate>Mon, 08 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://Littlehalo.github.io/posts/vue%E4%B8%ADaxios%E5%B0%81%E8%A3%85/</guid>
      <description>关于axios在vue中的封装以及遇到的一些问题 在src目录下建立文件夹utils/http.js和api/api.js http.js配置 &#39;use strict&#39;import axios from &#39;axios&#39;import qs from &#39;qs&#39;axios.interceptors.request.use(config =&amp;gt; {// loadingreturn config}, error =&amp;gt; {return Promise.reject(error)})axios.interceptors.response.use(response =&amp;gt; {return response}, error =&amp;gt; {return Promise.resolve(error.response)})function checkStatus (response) {// loading// 如果http状态码正常，则直接返回数据if (response &amp;amp;&amp;amp; (response.status === 200 || response.status === 304 || response.status === 400)) {return response// 如果不需要除了data之外的数据，可以直接 return response.data}// 异常状态下，把错误信息返回去return {status: -404,msg: &#39;网络异常&#39;}}function checkCode (res) {// 如果code异常(这里已经包括网络错误，服务器错误，后端抛出的错误)，可以弹出一个错误提示，告诉用户if (res.</description>
    </item>
    
    <item>
      <title>再一次搭建博客</title>
      <link>https://Littlehalo.github.io/posts/%E5%86%8D%E6%AC%A1%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://Littlehalo.github.io/posts/%E5%86%8D%E6%AC%A1%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>再一次搭建博客，这次使用的是gitte，只是简单的以为国内代码托管平台可能会更快点，没想到却遇见了很多棘手的问题，hexo download下来但是不能hexo d到gitte仓库上去，后面更加是牵扯到了ssh公钥的问题上去，后面导致连本地代码都不能push上去，后来想到一个蠢方法，就是简单的把hexo代码push上去就可以了，在一键部署上去，能简单使用了就可以了，后面的自己研究，就当是一个自己的笔记把
本地代码 推送到gitte步骤：
 git init git add . git commit -m &amp;quot; &amp;quot; git remote add origin url git push -u origin master  删除自己的有关联的分支
find . -name &amp;ldquo;.git&amp;rdquo; | xargs rm -Rf
 调试了一天，配置了太多太多都没有用，后面改用hugo搭建了博客  在config.toml中改参数 生成public: 打开文件根目录的cmd或git bash here输入hugo 进入public 在该页面下打开git bash here 相继输入以下代码  git init git add -Agit commit -am&amp;quot;init&amp;quot;git remote add origin https://github.com/你的用户名/你的用户名.github.io.git（假如是我：git remote add origin https://github.com/spiritLHL/spiritLHL.github.io.git）git push -f origin master（无响应则再次运行同一代码，最多两次）ok!</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://Littlehalo.github.io/about/</link>
      <pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://Littlehalo.github.io/about/</guid>
      <description>Hugo is the world’s fastest framework for building websites. It is written in Go.
It makes use of a variety of open source projects including:
 https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Learn more and contribute on GitHub.</description>
    </item>
    
    <item>
      <title>About Hugo</title>
      <link>https://Littlehalo.github.io/about-hugo/</link>
      <pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://Littlehalo.github.io/about-hugo/</guid>
      <description>Hugo is the world’s fastest framework for building websites. It is written in Go.
It makes use of a variety of open source projects including:
 https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Learn more and contribute on GitHub.</description>
    </item>
    
  </channel>
</rss>